\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\let\babellll\lll
\let\lll\relax

\usepackage{graphicx}    % Pakiet pozwalaj¹cy ,,wklejaæ'' grafikê...
\usepackage{caption}
\usepackage{subcaption}
\usepackage{epstopdf}
\usepackage{amsmath,amssymb,amsfonts,amsthm,mathtools}
                               % Do³¹czamy zestaw ró¿nych przydatnych znaczków ...

\usepackage{url}

%\usepackage{comment}  
%\usepackage[left = 2.5cm]{geometry}
%\usepackage{bbm}               % \mathbbm{N} - zbior liczb naturalnych
%tikz

\date{Wrocław, \today}
\title{\LARGE{\textbf{Rozwiązania niektórych z około dwustu łatwych zadań z języków formalnych i złożoności obliczeniowej 
(i jednego nie aż tak trudnego, jak się o nim mówi)}\\\Large{Numeracja zadań jak w zbiorze z 2017 roku}}}

\author{}

\newtheorem{innercustomthm}{Zadanie}
\newenvironment{zadanie}[1]
  {\renewcommand\theinnercustomthm{#1}\innercustomthm}
  {\endinnercustomthm}
  
\newtheorem{innercustomobs}{Obserwacja}
\newenvironment{obserwacja}[1]
  {\renewcommand\theinnercustomobs{#1}\innercustomobs}
  {\endinnercustomobs}
 

\begin{document}

\maketitle

\section{Wskazówki}

Patrząc perspektywicznie w stronę zbliżających się egzaminów, ta sekcja wydaje mi się ważnejsza i zachęcam do spędzania z nią
czasu podczas samodzielnych wieczornych rozmyślań.

\subsection{Języki i automaty}

\begin{zadanie}{63}
Warto zastanowić się, jak miałby wyglądać niedeterministyczny automat ze stosem rozpoznający taki język. Pomocny może się też
okazać pewien lemat.
\end{zadanie}

\subsubsection{Języki rodzynkowe}

\begin{zadanie}{71}
Probem sprowadza się do rozpoznawania liter języka $L^*$. \\
Gdyby miał istanieć taki język L, to pewnie musiałby być nieskończony (dlaczego?). Może istnieje jakaś prosta, nieskończona
rodzina słów postaci $a^*ba^*$, którą automat ze stosem może łatwo rozpoznawać, ale taki bez stosu będzie miał trudniej?
Formalnie, jak to bywa, warto używać lematów.
\end{zadanie}


\begin{zadanie}{72}
Wskazówka z treści zadania wydaje się bardzo dobra. Tu cytat: "Warto rozważyć słowa postaci $a^k(ba^{2n})^l$, dla odpowiednich
liczb $k$ i $l$."
\end{zadanie}

\begin{zadanie}{73}
Raczej chodzi o oszacowanie $i(L_nL_n) \geqslant c2^{i(L_n)}$, przy założeniu że $i(L_n) \geqslant n$, inaczej to nie ma sensu.
Możnaby najpierw pomyśleć, dlaczego w przypadku NDFA nie można udowodnić takiego oszacowania. A potem zmusić DFA, żeby pamiętał
dużo tego, co NDFA pamiętać nie musi, bo może zgadnąć. 
\end{zadanie}

\subsection{Obliczalność}

\begin{zadanie}{92}
Jak coś ma nie być r.e. to na pewno chodzi o redukcję z $\overline{K}$. Delikatna modyfikacja 89.
\end{zadanie}

\begin{zadanie}{99}
i) Jak coś ma nie być r.e. to na pewno chodzi o redukcję z $\overline{K}$. Delikatna modyfikacja 89. \\
ii) Czy $\Phi_m \neq \Phi_n \Longleftrightarrow \exists k \Phi_m(k) \neq \Phi_n(k)$?
\end{zadanie}

\begin{zadanie}{101}
Trzeba wprost zdefiniować redukcję z B do A. 
\end{zadanie}

\begin{zadanie}{102}
a. założenie o nietrywialności zadania b. implikuje odpowiedź w zadaniu a.. Pewna użyteczna redukcja i w tym zadaniu okaże się
pomocna. \\
b. formalne sformułowanie tego, co to znaczy że $n \in B$, używająca 3 zmiennych, wprost prowadzi do co-r.e. zbioru A.
\end{zadanie}

\begin{zadanie}{103}
Należałoby się zastanowić, co wspólnego mają te warunki z monotonicznością f.
\end{zadanie}

\section{Szkice rozwiązań}

\subsection{Języki i automaty}

\subsubsection{Synchronizacja automatów częściowych}

\begin{zadanie}{40}
\end{zadanie}

Odp: NIE. \\


\begin{figure}[h!]
  \centerline{%
    \includegraphics[width=6cm]{zad40.png}%
  }%
  \caption{$csync(\{1,2\}) \supset \{a\}; \ csync(\{1,3\}) \supset \{b\};\ csync(\{1,2\}) \supset \{c\}$. Natomiast $csync(Q) = \emptyset $.}
\end{figure}


\begin{zadanie}{41}
\end{zadanie}
W obydwu podpunktach wystarczy zbadać funkcję

\begin{align*}
 F :\ &2^Q \times \Sigma \longrightarrow 2^Q \\
 F(S,a) &= \{ \delta(q,a) : \ q \in S \}.
\end{align*}

Oczywiście $s \in csync(S) \Longleftrightarrow |\widehat{F}(S,s)| = 1$, gdy zdefiniujemy $\widehat{F}$ w naturalny sposób. 
Ponadto $1 \leqslant |F(A,a)| \leqslant |A|$, zatem $1 \leqslant |\widehat{F}(S,p)| \leqslant |S|$ dla dowolnego prefiksu $p$ słowa $s$,
czyli $\widehat{F}(S,p)$ może przyjmować co najwyżej $\displaystyle{\sum\limits^{|S|}_{k=1}\binom{|Q|}{k}}$ różnych wartości.
Oznaczmy tę liczbę jako $M$. \\ \\

Dla $|s| > M$ istnieją prefiksy $p_1$ i $p_2$ słowa $s = p_1s_1 = p_2s_2, \ |p_1| < |p_2|,$ takie że 
$\widehat{F}(S,s_1) = \widehat{F}(S,s_2)$ (Zasada Szufladkowa). Wtedy oczywiście $\widehat{F}(S,s) = \widehat{F}(S,p_1s_2)$, przy czym 
$|p_1s_2| < |s|$. \\ \\
W zwiazku z powyższym $csync(Q) \neq \emptyset \Longleftrightarrow \exists s \in S |s| \leqslant M$. \\
Dokładne odpowiedzi wynikają z tego wprost, po podstawieniu za $S$ a) dowolniego trzyelementowego zbioru stanów b) Q. \\ \\

\begin{zadanie}{42}
\end{zadanie}
Wystarczy rozwiązać M, L i XL wynikają w prosty sposób. Wskazówka jest myląca. \\ \\

Zbudujmy automat (częściowy) z trzech cykli, ułożonych jeden nad drugim, każdy długości m. Trzy stany, ułożene jeden nad
drugim, będą stanowiły nasz początkowy zbiór S \\ \\

\begin{figure}[h!]
  \centerline{%
    \includegraphics[width=18cm]{zad42.png}%
  }%
\end{figure}

Naszym celem jest, aby co jedną literę zmieniał się stan na górnym cyklu, co $m$ liter stan na drugim, a co $m^2$ na trzecim.
Zapenimy też, że synchronizacja będzie mogła nastąpić dopiero po przejściu przez dolny stan całego cyklu (czyli $~m^3$ krokach). \\
Możemy to wymusić w następujący sposób: \\

\begin{figure}[h!]
  \centerline{%
    \includegraphics[width=18cm]{zad42_2.png}%
  }%
\end{figure}

przy czym pętelki z literą a są przy każdym stanie na drugim dysku, a pętelki z literami a,b są przy każdym stanie na trzecim
dysku. \\
Możliwość synchronizacji zapeniamy przez dodanie przejść z przedostatnich stanów na każdym dysku do pierwszego stanu 
dolnego dysku. Oznaczenie ich specjalną ``literką synchronizacji'', jak d, zapewni nam, że skorzystać z niej będzie można
dopiero gdy dolny stan dojdzie do przedostatniego miejsca na dolnym dysku (co następuje dopiero po $~m^3$ krokach: \\
\begin{figure}[h!]
  \centerline{%
    \includegraphics[width=18cm]{zad42_3.png}%
  }%
\end{figure}

Zauważmy teraz, że ten automat (zanim dojedzie do synchronizacji) jednoznacznie wyznacza słowo, dla którego funkcja przejścia 
jest określona dla wszystkich stanów z $S$:
$$
s = ((a^{m-1}b)^{m-1}c)^{m-1}d
$$
Takie $s$ synchronizuje $S$ i nie istnieje żadne krótsze od niego. Nietrudno wyliczyć, że jest ono odpowiednio długie. \\ \\

Co do wersji L i XL, wystarczy zauważyć, że:
\begin{enumerate}
 \item To samo rozumowanie można zastosować dla dowolnie wielu cykli, otrzymując wielomian dowolnie dużego stopnia.
 \item Potrzebny nam alfabet, który ma $k+1$ liter (gdzie $k$ jest liczbą cykli). Ale dowolny alfabet można zamienić na
 dwuliterowy, zapisując jego $l$-tą literę w postaci $0^l1$. To działa.
\end{enumerate}

Dodatkowo, dodając pętle z literką przejścia na przedostatnich stanach każdego cyklu, zamienimy nasz automat na taki, który
synchronizuje wszystkie stany ( pierwszy stan każdego cyklu ``zjada'' wszystkie kolejne w pierwszym przejściu cyklu):
\begin{figure}[h!]
  \centerline{%
    \includegraphics[width=18cm]{zad42_4.png}%
  }%
\end{figure}


\begin{zadanie}{63}
\end{zadanie}
Przypuśćmy nie wprost, że ten język jest bezkontekstowy. Niech $N$ będzie stałą z lematu o pompowaniu dla tego języka. 
Wystarczy rozważyć słowo $0^{2N}1^{2N}0^{2N}1^{2N}$ i pamiętać, że przy podziale z lematu (ozn. $vwxyz$) zachodzi
$|wxy| \leqslant N$. Odpowiednio cierpliwe rozpatrywanie przypadków (gdzie w oryginalnym słowie ląduje podsłowo $wxy$)
prowadzi nas do wniosku, że zawsze można odpowiedni fragment podpompować (lub spompować) i uzyskać słowo spoza języka.


\subsubsection{Języki rodzynkowe}

\begin{zadanie}{71}
\end{zadanie}
Rozważmy $L = \{ a^nba^n : n \in \mathbb{N}\}$. Łatwo sprawdzić, że nawet deterministyczny automat ze stosem daje sobie radę
z językiem $L*$, bo rozpoznawanie liter tego języka (czyli słów języka $L$) jest bardzo łatwe. \\
Z lematu o pompowaniu bardzo łatwo pokazać, że $L*$ nie jest regularny ($L$ też nie jest).


\subsubsection{Transducery}

\begin{zadanie}{77}
\end{zadanie}
Podpunkt 1: definiujemy $\sigma_{Mealy} = \sigma_{Moore} \circ \delta$. Reszta zostaje.\\
Podpunkt 2: definiujemy (dla transducera Mealy'ego $\langle \Sigma, \Sigma_1, Q, q_0, \delta, \sigma_{Mealy} \rangle$)
\begin{enumerate}
 \item $Q' = Q \times \Sigma \cup q_0'$. Stan $(q,a)$ = stan do którego doszlibyśmy w starym automacie ze stanu $q$ wczytując
 literę $a$. Stan $q_0'$ - dodatkowy stan początkowy.
 \item 
 \subitem $\delta'((q,a),b) = (\delta(q,a),b)$ dla pary $(q,a) \in Q \times \Sigma$
 \subitem $\delta'(q_0',a) = (q_0,a)$
 \item
 \subitem $\sigma_{Moore}((q,a)) = \sigma_{Mealy}(q,a)$
 \subitem $\sigma_{Moore}(q_0') = \varepsilon$
\end{enumerate}
Otrzymujemy transducer Moore'a $\langle \Sigma, \Sigma_1, Q', q_0', \delta', \sigma_{Moore} \rangle$ równoważny z pierwotnym
t. Mealy'ego. \\
Dowód w obu przypadkach zapewne angażuje Zasadę Indukcji Matematycznej względem długości słowa. \\ \\ 

\begin{zadanie}{78}
\end{zadanie}
bso. (77) zajmijmy się transducerem Mealy'ego $\langle \Sigma, \Sigma_1, Q, q_0, \delta, \sigma_{Mealy} \rangle$, który 
świadczy że $A \leqslant_{reg}B$. Niech przy okazji $A_B = \langle \Sigma_1, Q^B, q_0^B, F^B, \delta^B\rangle$ będzie DFA
rozpoznającym $B$. Definiujemy $\delta'(q,a) = \widehat{\delta^B}(q,\sigma_{Mealy}(q,a))$. Udajemy, że jesteśmy słowem z języka
$B$ i chodzimy po automacie $A_B$.\\
Wtedy $\langle \Sigma, Q^B, q_0^B, F^B, \delta' \rangle$ jest DFA rozpoznającym $A$ (d-d. indukcyjny względem długości słowa). \\ \\

\begin{zadanie}{79}
\end{zadanie}
Definiujemy transducer Mealy'ego $T_{Mealy}$:
\begin{enumerate}
 \item $\Sigma = \{1,2,3,...,n\}$
 \item $Q = \Sigma$
 \item $q_0 = 1$
 \item $\delta(q,a) = a$
 \item $\Sigma_1 = Q \times \Sigma$
 \item $\sigma_{Mealy} = Id$
\end{enumerate}

Niech $T_{Moore} = \langle \Sigma, \Sigma_1, Q', q_0', \delta', \sigma_{Moore} \rangle$ będzie transducerem Moore'a 
równoważnym z $T_{Mealy}$.

\begin{obserwacja}{1}
 Możemy założyć, że każdy stan z $Q'$ jest osiągany przez DFA stowarzyszony z $T_{Moore}$. W przeciwnym razie możemy usunąć te 
 stany, a powstały $T_{Moore}'$ wciąż będzie równoważny z $T_{Mealy}$.
\end{obserwacja}

\begin{obserwacja}{2}
 $s \in Im(\sigma_{Mealy}) \Rightarrow |s| = 1$. Zatem $s \in Im(\sigma_{Moore}) \Rightarrow |s| = 1$.
\end{obserwacja}

Gdyby było $|Q'| < n^2$, to $Im(\sigma_{Mealy}) \nsubseteq Im(\sigma_{Moore})$. Niech 
$s \in Im(\sigma_{Mealy}) \setminus Im(\sigma_{Moore})$. $s = (k,l)$ dla pewnych $k,l \in \Sigma$. Rozważmy słowo
$t = kl$. Wtedy $f_{T_{Mealy}}(t) = \sigma_{Mealy}(1,k) \sigma_{Mealy}(k,l) = (1,k)(k,l)$. \\
Załóżmy nie wprost, że $f_{T_{Moore}}(t) = f_{T_{Mealy}}(t)$. Jest to równoważne (obs. 2) z tym, że 
$\sigma_{Moore}(\delta'(q_0',k)) = \sigma_{Mealy}(1,k)$ oraz 
$\sigma_{Moore}(\widehat{\delta'}(q_0',kl)) = \sigma_{Mealy}(k,l) = (k,l)$. 
Druga równość stoi w jawnej sprzeczności z naszym założeniem, że $(k,l) \notin Im(\sigma_{Moore})$.

\begin{zadanie}{80}
\end{zadanie}
Zdaje się, że świadczy o tym następujący transducer Mealy'ego:
\begin{enumerate}
 \item $\Sigma = \{(,),[,],\langle,\rangle \}$
 \item $Q = \{q_0\}$
 \item $q_0 = q_0$
 \item $\delta \equiv q_0$
 \item $\Sigma_1 = \{(,),[,] \}$
 \item
 \subitem $\sigma_{Mealy}( q_0, (/) ) = ((/)) $
 \subitem $\sigma_{Mealy}( q_0, [/] ) = [[/]] $
 \subitem $\sigma_{Mealy}( q_0, \langle / \rangle ) = [(/)] $
\end{enumerate}
Dowód pozostawiamy Czytelnikowi jako ćwiczenie. 

\subsection{Obliczalność}

\begin{zadanie}{89}
\end{zadanie}
Niech $B = \{ n : Dom(\Phi_n) = \mathbb{N} \}$. Robimy redukcję $f_{89}$ z $\overline{K}$. \\
Definiujemy $f_{89}(n)$ jako numer następującego programu: \\
\texttt{wczytaj k  \\ odpal $\Phi_n(n)$ na $k$ kroków \\ jeżeli się skończył : zapętl się \\ w p.p. : zwróć 1 \\}
Sprawdzenie, że zachodzi $n \in \overline{K} \Longleftrightarrow f_{89}(n) \in B$ pozostawiamy jako proste ćwiczenie.



\begin{zadanie}{92}
\end{zadanie}
Robimy redukcję $f_{92}$ z $\overline{K}$. \\
Definiujemy $f_{92}(n)$ jako numer następującego programu: \\
\texttt{wczytaj k \\ jeżeli k jest parzyste : zapętl się  \\ w p.p. : \\ odpal $\Phi_n(n)$ na $k$ kroków \\ jeżeli się skończył : zapętl się \\ w p.p. : zwróć 1 \\}
Oczywiście $Dom(\Phi_{f_{92}(n)}) = (2\mathbb{N}+\{1\}) \cap \{ t \in \mathbb{N} : t < \text{czas wykonania się } \Phi_n(n) \}$. \\
Sprawdzenie, że zachodzi $n \in \overline{K} \Longleftrightarrow f_{92}(n) \in B$ pozostawiamy jako proste ćwiczenie.

\begin{zadanie}{99}
\end{zadanie}
i) Robimy redukcję f z $\overline{K}$, pamiętając o redukcji $f_{89}$. \\
Niech $c$ będzie numerem następującego programu: \\
\texttt{wczytaj k  \\ zwróć 1 \\}
Definiujemy $f(n) = \langle c , f_{89}(n) \rangle$. Jest oczywiste (po zrobieniu zadania $89$), że zachodzi \\
$$
n \in \overline{K} \Longleftrightarrow f(n) \in T.
$$
ii) Nie. Robimy redukcję f z $\overline{K}$, pamiętając o redukcji $f_{92}$. \\
Niech $\overline{f_{92}}$ będzie numerem następującego programu: \\
\texttt{wczytaj k \\ jeżeli k jest nieparzyste : zwróć 1  \\ w p.p. : \\ odpal $\Phi_n(n)$ na $k$ kroków \\ jeżeli się skończył : zwróć 1 \\ w p.p. : zapętl się \\}
Definiujemy $f(n) = \langle \overline{f_{89}}(n) , f_{89}(n) \rangle$. Jest oczywiste (po zrobieniu zadania $92$), że zachodzi \\
$$
n \in \overline{K} \Longleftrightarrow f(n) \in \overline{T}.
$$

\begin{zadanie}{101}
\end{zadanie}
Definiujemy $f^{-1}$ w następujący sposób: \\
\texttt{wczytaj n \\ Dla $k=1,2,3...$ : \\ jeżeli $f(k) = n$ : zwróć k \\ }
Oczywiście $f^{-1}$ jest całkowita, bo $f$ jest ``na". \\
Pokażemy, że $f^{-1}$ jest redukcją z $B$ do $A$ :
\begin{align}
 n \in B \Longleftrightarrow Id(n) \in B \Longleftrightarrow f(f^{-1}(n)) \in B \Longleftrightarrow
 
\end{align}



\begin{zadanie}{102}
\end{zadanie}
a) Nie. Wysztarczy pokazać redukcję z $K$ (dlaczego?). O dziwo, jest to dokładnie $f_{89}$. \\
b) Definiujemy $A = \{ (n,k,t) : \Phi_n(i) \text{ kończy się po co najwyżej $t$ krokach dla } \\ 
i=1,2,...,k \text{ oraz nie kończy się dla $i > k$} \}$. Ten zbiór jest dobry, a sprawdzenie pozostawiamy jako ćwiczenie.

\end{document}
